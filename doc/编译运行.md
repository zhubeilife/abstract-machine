编译生成一个可以在NEMU的运行时环境上运行的程序的过程大致如下:

* gcc将 `$ISA-nemu`的AM实现源文件编译成目标文件, 然后通过ar将这些目标文件作为一个库, 打包成一个归档文件 `abstract-machine/am/build/am-$ISA-nemu.a`
* gcc把应用程序源文件(如 `am-kernels/tests/cpu-tests/tests/dummy.c`)编译成目标文件
* 通过gcc和ar把程序依赖的运行库(如 `abstract-machine/klib/`)也编译并打包成归档文件
* 根据Makefile文件 `abstract-machine/scripts/$ISA-nemu.mk`中的指示, 让ld根据链接脚本 `abstract-machine/scripts/linker.ld`, 将上述目标文件和归档文件链接成可执行文件

根据上述链接脚本的指示, 可执行程序重定位后的节从 `0x100000`或 `0x80000000`开始 (取决于 `_pmem_start`和 `_entry_offset`的值), 首先是 `.text`节, 其中又以 `abstract-machine/am/src/$ISA/nemu/start.S`中自定义的 `entry`节开始, 然后接下来是其它目标文件的 `.text`节. 这样, 可执行程序起始处总是放置 `start.S`的代码, 而不是其它代码, 保证客户程序总能从 `start.S`开始正确执行. 链接脚本也定义了其它节(包括 `.rodata`, `.data`, `.bss`)的链接顺序, 还定义了一些关于位置信息的符号, 包括每个节的末尾, 栈顶位置, 堆区的起始和末尾.

我们对编译得到的可执行文件的行为进行简单的梳理:

1. 第一条指令从 `abstract-machine/am/src/$ISA/nemu/start.S`开始, 设置好栈顶之后就跳转到 `abstract-machine/am/src/platform/nemu/trm.c`的 `_trm_init()`函数处执行.
2. 在 `_trm_init()`中调用 `main()`函数执行程序的主体功能, `main()`函数还带一个参数, 目前我们暂时不会用到, 后面我们再介绍它.
3. 从 `main()`函数返回后, 调用 `halt()`结束运行.
